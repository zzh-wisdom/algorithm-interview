# 基础知识

多态：

在类继承的时候，用父类指针调用虚函数时，会根据实际的对象类型决定函数调用的具体目标
（相同的行为方式可能导致不同的行为结果，即产生了多种形态行为，即多态）

而且是**运行时决定**的，同样的调用语句在实际运行时有多种不同的表现形态；父类指针在运行时指向不同的子类。
（同一行语句展现了多种不同的表现形态，多态本质）

## 公有继承

### virtual 作用

<https://www.cnblogs.com/xinxue/p/5471708.html>

1. 纯虚函数: 继承的是基类中，成员函数的接口，只有接口被继承，其缺省的实现不会被继承。要在派生类中，**重写成员函数的实现**
2. 普通虚函数，会在基类中，定义一个**缺省的实现 (default implementation)**，表示继承的是基类成员函数接口和缺省实现，由派生类选择是否重写该函数。

**普通虚函数同时继承接口和缺省实现是危险的**，最好是基类中实现缺省行为 (behavior)，但只有在派生类要求时才提供该缺省行为.解决方法：1）纯虚函数 + 缺省实现；2）C++11 中使用关键字 override，可以避免“不小心”忘记重写/重载

### 非虚函数

非虚函数

非虚成员函数没有 virtual 关键字，表示派生类**不但继承了接口，而且继承了一个强制实现** (mandatory implementation)

既然继承了一个强制的实现，则在派生类中，无须重新定义 (redefine) 继承自基类的成员函数。

> 非虚函数是 “静态绑定” 的，pB 被声明的是 Shape* 类型的指针，则通过 pB 调用的非虚函数都是基类中的，既使 pB 指向的是派生类
>
> 与“静态绑定”相对的是虚函数的“动态绑定”，即无论 pB 被声明为 Shape* 还是 Rectangle* 类型，其调用的虚函数取决于 pB 实际指向的对象类型
